Перед реализацией основной логики я себе поставил следующие требования:
- сделать ограничение количества горутин;
- если при расчете переменной будет ошибка, то сразу завершать все горутины (я предполагаю, что инструкции формируют одно целое и даже с одной ошибкой расчета мы не можем продолжать работать дальше. Это просто бессмысленно выводить ответ, который будет валиден только на половину);
- определять используемые переменные заранее, чтобы не пытаться бесконечно ждать их в горутинах, которым они нужны.

Для первых двух пунктов идеально подходит sync.errgroup. В нём мы сразу определяем количество горутин, которые могут быть запущены параллельно, тем самым убирая велосипеды с воркер пулами и тд. Также в нём можно использовать контекст для отмены других горутин, если возникнет ошибка.

Для ожидания переменных сначала использовал подход с каналами, но потом я открыл для себя sync.Cond, который позволяет сделать "подписку" и ждать события. Интересная вещь и как мне показалось, с ним код выглядит более читабельно.

Логика работы будет такая:
1. Перед запуском горутин с расчетом переменных я прохожусь в цикле по всем инструкциям и записываю их в мапу mask. Это позволит горутинам сразу проверить, будет ли в будущем переменная, которая им нужна. Если переменной в маске нет, то выбрасываю ошибку о том, что используется неизвестная переменная и завершаю все остальные горутины.
2. Если приходит инструкция с "calc", то запускается горутина на её расчет. Если приходит инструкция с "print", то я её складываю в временный массив tmp. Он нужен для того, чтобы в будущем вывести ответ в правильном порядке.
3. Если переменная уже есть в мапе с итоговыми значениями (мапка intermediateValues), то берем её от туда, если нет, то при помощи sync.Cond делаем cond.Wait() и блочим горутину до тех пор, пока какая то другая горутина не сделает рассылку о появлении новой переменной.
4. Когда переменная будет расчитана, то я помещаю её в мапу с итоговыми значениями и делаю cond.Broadcast, который уведомляет ожидающие горутины о том, что появилась новая переменная.
5. Ожидающие горутины выходят из блокировки и проверяют, появилась ли нужная им переменная в мапе с итоговыми значениями.
6. Дальше просто прохожусь по массиву tmp и вывожу ответы в правильном порядке.

Для меня главной проблемой оказалась работа с sync.Cond, а именно то, что он использует тот же мьютекс, что я использую для блокировки при чтении/записи с мапами. Из-за изначально плохого понимания работы sync.Cond и моей глупости возникали случаи двойного анлока. Но всё удалось удачно исправить.

Также была проблема с cond.Broadcast. Открылась она на моменте, когда я писал тесты и передал невалидную переменную в самом начале, а не в середине (забавно, что когда я передавал невалидные данные в середине массива инструкций, то всё отрабатывало замечательно). Это приводило к тому, что мой запрос тупо зависал и бесконечно ждал, хотя должна была обработаться ошибка. Спустя день до меня дошло, что оповещать нужно при любой ошибке, а не только при успешном добавлении в мапку с итоговыми значениями и проблема ушла.

Для читабельности я решил вынести все нужные переменные и примитивы синхронизации в отдельную структуру InstructionsState, т.к. приходилось передавать слишком много одинаковых переменных в функции. А так я просто передаю по укзаателю одну структуру.
